1. 谈谈c++中的资源管理
    * 计算中的资源是个非常广泛的概念，内存、锁、文件、Socket等等都是资源
    * 资源的申请和释放需要成对出现，缺一不可，如:new和delete(内存)、lock和unlock(锁)、打开和关闭(文件)、建立套接字和关闭
    * 在编码过程中经常会经过a.获取资源、b.使用资源、c.释放资源，这个时候需要注意中途退出(return,goto)的情况也需要手动释放资源
    * 建议使用RAII方式管理资源
    
2. 谈谈深拷贝&浅拷贝
    * 对一个已知对象进行拷贝，编译系统会自动调用一种构造函数拷贝构造函数，
        如果用户未定义拷贝构造函数，则会调用默认拷贝构造函数，它能够完成成员的一一复制。
    * 当数据成员中没有指针时，浅拷贝是可行的；
        但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针成员将指向同一个地址，
        当一个对象析构时，另一个对象的指针成员指向的地址已经被释放，而导致指针悬挂现象，此时，必须采用深拷贝。
    * 深拷贝与浅拷贝的区别就在于深拷贝会在（堆）内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。
        简而言之，当数据成员中有指针时，需要用深拷贝。
    
3. 谈谈类的特殊成员函数、类的三法则(或五法则)
    c++中类的特殊成员函数分别是：
    - 默认构造函数（default constructor）
    - 析构函数（destructor）
    - 复制构造函数（copy constructor）
    - 复制赋值运算符（copy assignment operator）
    - 移动构造函数（move constructor）
    - 移动赋值运算符（move assignment operator）
    * 若某个类需要用户自定义的析构函数、复制构造函数或复制赋值运算符，则几乎肯定需要它们三(或五)者部都
    * 一般在类需要管理资源的时候才会显示的定义
    * 建议一个类只管理一个资源
    
4. RAII（Resource Acquisition Is Initialization）是什么及其原理和惯用法
    * 中文翻译为资源获取即初始化，使用局部对象来管理资源的技术称为RAII
    * 资源使用过程一般分为三个：a.获取资源、b.使用资源、c.释放资源；销毁资源的过程容易被遗忘，
        使用RAII可以在局部对象的析构函数中释放资源，当退出了这个局部对象的作用域时，
        就会销毁局部对象而调用局部对象的析构函数，从而释放资源
        可以减轻开发人员的心智负担
    * 在标准库中也有许多RAII的应用如：std::lock_guard
    
5. 使用STL
    * 内容
        容器（Containers） ：容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。
        算法（Algorithms） ：算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。
        迭代器（iterators）：迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。
    * 容器
        vector：动态数组，支持快速随机访问，在尾部意外的地方插入效率较低，适合需要频繁随机读取的场景，不能存储引用
        list  ：双向链表，支持双向的顺序访问，在任何地方插入或删除都有较高效率，适合大对象或者随机写频繁不要求随机读取的场景
        deque ：多个连续的内存块。并且在一个映射结构中保存对这些块以及顺序的跟踪（双端队列），擅长在头尾两端进行元素的插入跟删除操作；
            支持随机访问，即支持[]以及at()，但是性能没有vector好；
            可以在内部进行插入和删除操作，但性能不及list。
        priority_queue：堆，队首元素一定是当前队列中优先级最高的那一个
        map、set、multiset、multimap：都是红黑树，multi前缀的容器允许重复的key存在，内存占用较少，根据key查询时间复杂度为O(logN)
        unordered_map、unordered_set：防冗余的哈希表，占用内存较多，根据key查询时间复杂度为O(1)
    * 迭代器
        迭代器的类型: 输入、输出、前向、双向和随机访问,
        迭代器的失效：
            https://ivanzz1001.github.io/records/post/cplusplus/2018/03/14/cpluscplus_stl_iterator
    算法：
        https://blog.csdn.net/fengbingchun/article/details/78034969
    仿函数：仿函数（Functor）又称为函数对象（Function Object）是一个能行使函数功能的类。
        仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载 operator() 运算符。
        因为调用仿函数，实际上就是通过类对象调用重载后的 operator() 运算符。
    
6. 面向对象的特点，，
    封装：将外部故关心的成员隐藏(设置为private)，隐藏实现细节，使得代码模块化，高内聚
    继承：可以在无需修改现有类的情况下使用其功能的能力，重用现有的功能
    多态：允许将子类类型的指针赋值给父类类型的指针，并且可以统一的方式对待父类的所有子类
        多态时使用覆盖来实现的，当子类与父类拥有相同签名(函数名，参数，返回值)的虚函数叫做覆盖
        覆盖的机制时虚函数表(vtable)
    单一职责原则SRP(Single Responsibility Principle)：是指一个类的功能要单一
    开放封闭原则OCP(Open－Close Principle)：一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的
    里式替换原则LSP(the Liskov Substitution Principle LSP)：子类应当可以替换父类并出现在父类能够出现的任何地方
    依赖倒置原则DIP(the Dependency Inversion Principle DIP)：具体依赖抽象，上层依赖下层
    接口分离原则ISP(the Interface Segregation Principle ISP)：模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来
    
7. 重载决议
    重载决议就是根据给定的调用表达式来选择函数去调用的过程，就是编译时确定调用的时哪一个重载函数的过程
    编译查找重载函数过程：
        1. 寻找该名字，组成一个初始的"重载集合"
        2. 必要的话，该集合会通过多种方式来调整(例如，模板实参的推断和替换时，会导致一些函数模板候选者被丢弃)
        3. 所有不完全匹配调用的候选者(即使在考虑了隐式转换和默认实参之后)会从重载集合中排除掉。结果会形成可用的候选函数集合。
        4. 执行重载决议来找到一个最佳的候选函数。如果存在一个，就选择他。否则，这个调用就是引起歧义的。
        5. 检查被选择的候选函数。例如，如果它是一个被删除的函数(i.e. 以=delete定义)或是一个不可用的私有成员函数，则会报告诊断出问题
    重载决议过程：
        1.完美匹配。参数就是表达式的类型，或者是表达啊是类型的引用(也可以加上const 或 volatile的限定符).
        2.通过微小的调整来匹配。距离，包括一个数组变量退化为一个指向其首元素的指针或者添加const使实参类型int** 来匹配形参类型int const* const*
        3.通过类型提升来匹配。类型提升是一种隐式转换，包括从小的整数类型(例如bool,char,short,有时包括枚举类型)转换为int,unsigned int, long, unsigned long类型，以及float转换为double
        4.仅通过标准转换来匹配。这包括任意种类的标准转换(例如int转为float)或者从继承类转换为一个公用的(public)，明确的基类，但是要排除对类型转换运算符和转换构造函数的隐式调用。
        5.通过用户定义的转换来匹配。这允许任意种类的隐式转换。
        6.通过省略号来匹配(...)。省略号形参几乎可以匹配任意类型。不过，存在一个例外，拥有非平凡的拷贝构造函数(nontrivial copy constructor)的类类型不一定是有效的(具体实现可以自由的允许或禁止这种匹配).
    
8. 异常：栈开解/栈展开（stack-unwinding）的过程；什么时候抛出异常；在什么抽象层面上抛出异常
    栈开解: 当程序静态创建对象（在堆栈上而不是在堆内存中创建）并调用函数时，它们被“堆叠”。
        当一个作用域（由{和}包裹的部分）退出（通过使用return、到达作用域的末尾或抛出异常）时，
        该范围内的所有栈上的对象都被销毁（为他们调用析构函数）。这种销毁本地对象和自动调用析构函数的过程称为堆栈展开。
        （使用goto退出代码块不会进行栈开解 ，所以不应该在C++中使用goto）。
    
    更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常。这种做法被称为异常转译
